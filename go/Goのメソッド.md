## メソッド

Goは[[ユーザー定義型]]に付随する関数を定義できる。これを **[[型メソッド]]** (type method) あるいは単に **[[メソッド]]** (method) と呼ぶ。

メソッドの宣言は[普通の関数の宣言](Goの関数.md#関数の宣言)とよく似ているが、`func` とメソッド名の間に **[[レシーバ]]** (receiver) が追加されている。

```go
type Person struct {
	FirstName string
	LastName  string
	Age       int
}

// 型 Person に付随するメソッド String を定義 (Person にメソッド String を追加)
func (p Person) String() string {
	return fmt.Sprintf("%s %s : 年齢%d歳", p.LastName, p.FirstName, p.Age)
}
```


```go
func main() {
	p := Person{
		LastName:  "武田",
		FirstName: "信玄",
		Age:       52,
	}

	output := p.String()
	fmt.Println(output) // 武田 信玄 : 年齢52歳
}
```

## ポインタ型レシーバと値型レシーバ

レシーバには **[[ポインタレシーバ]]** と **[[値レシーバ]]** の2種類がある。

どちらの種類のレシーバを使うか決めるためのルールは次の通り。

- メソッドがレシーバを変更する場合はポインタレシーバを **使わなければならない**
- メソッドが `nil` を扱う必要があれば、ポインタレシーバを **使わなければならない**
- メソッドがレシーバを変更しないなら値レシーバを **使うことができる**
  - 型にポインタレシーバのメソッドが1つでもあれば、(レシーバを変更しないものも含め) すべてのメソッドにポインタレシーバを使う[^2024-12-20-075542]

[^2024-12-20-075542]: https://go.dev/wiki/CodeReviewComments#receiver-type に "- Don’t mix receiver types. Choose either pointers or struct types for all available methods." とあったが、理由は書かれていない。<br>[【Go】値レシーバとポインタレシーバの違いと使い分けについて考える \#Go - Qiita](https://qiita.com/fujita-goq/items/ed8e8730b0976c3ff3a6) には「一つの型で値レシーバとポインタレシーバを混在させない（**統一性のため**）」とある。

ポインタレシーバに対してポインタでないローカル変数を渡すと、Goは自動的に変数をポインタ型に変換する。[この例](example/pointer_and_value_receivers.go) で言えば `c.Increment()` は `(&c).Increment()` に自動変換されて呼び出される。

```shell
% go run go/example/pointer_and_value_receivers.go
合計: 0, 更新: 0001-01-01 00:00:00 +0000 UTC
合計: 1, 更新: 2024-12-20 08:10:13.068416 +0900 JST m=+0.000084043
```

[関数に値を渡すときのルール](Goのポインタ.md#ポインタはミュータブルの印)が依然として適用されていることに注意する。関数にポインタではない引数を渡し、その値でポインタレシーバのメソッドを呼び出した場合、コピーに対してメソッドを呼び出していることになる。[この例](example/pointer_and_value_receivers2.go) を実行すると以下の出力が得られる。

```shell
% go run go/example/pointer_and_value_receivers2.go
NG: 合計: 1, 更新: 2024-12-20 08:27:54.184754 +0900 JST m=+0.000045709
main: 合計: 0, 更新: 0001-01-01 00:00:00 +0000 UTC
OK: 合計: 1, 更新: 2024-12-20 08:27:54.184871 +0900 JST m=+0.000162709
main: 合計: 1, 更新: 2024-12-20 08:27:54.184871 +0900 JST m=+0.000162709
```

`doUpdateRight` の引数の型は `*Counter` (型 `Counter` のポインタ (ポインタインスタンス))。これに関しては `Increment`, `String` どちらも呼び出すことができる。

### ゲッターとセッター

Goでは構造体に対して[[ゲッター]]メソッドや[[セッター]]メソッドは書かず、フィールドに直接アクセスすることが推奨されている[^2024-12-21-120141]。

[^2024-12-21-120141]: インタフェースの条件を満たすことが目的の場合、複数のフィールドを一度に更新したい場合、更新が値の代入だけで終わらない場合は例外。

## nilへの対応

Goは [[nil]] を引数にしてメソッドを呼び出すと、メソッドを起動しようとする (ほとんどの言語[^2024-12-21-121711]では何らかのエラーになるのに対して)。

[^2024-12-21-121711]: [[Objective-C]] では `nil` を指定してメソッドを起動しようとするが何もしない。

- 値レシーバのメソッドの場合 … ポインタが参照している値がないためパニックになる
- ポインタレシーバのメソッドの場合 … メソッドが `nil` を処理できる場合は有効な呼び出しになる

nil を受け付けることでコードが単純になる場合がある (ref: [example/nil_binary_tree.go](example/nil_binary_tree.go))。

ポインタレシーバは[関数の引数にポインタを渡す場合](Goのポインタ.md#ポインタはミュータブルの印)と同じように動作する。`nil` を受け取って `nil` ではないものに変更するポインタレシーバは書けない。ポインタレシーバを持つメソッドが `nil` に対応していないなら、`nil` の場合はエラーを返すようにすること。

## メソッドは関数

Goのメソッドは普通の関数と似ており、関数が使えるところは代わりにメソッドを使うことができる。

変数に代入し、それを使って呼び出せたり、他の関数やメソッドに引数として渡せたりできる。メソッドを値として扱うため、**[[メソッド値]]** (method value) と呼ばれる。

型自体から関数を作成することもできる。これを **[[メソッド式]]** (method expression) と呼ぶ。メソッド式の場合、最初の引数はメソッドのレシーバになる

例) `Adder` という型の構造体と、それをレシーバとして `int` 型の値 `val` をフィールド `start` に足した値を戻すメソッド `AddTo` を定義

```go
type Adder struct {
	start int
}

// 構造体 Adder をレシーバとするメソッドを定義
func (a Adder) AddTo(val int) int {
	return a.start + val
}

// フィールド start の値を10に指定して型 Adder のインスタンスを生成
myAdder10 := Adder{start: 10}
fmt.Println(myAdder10.AddTo(5)) // 15

// AddTo を変数に代入
f1 := myAdder10.AddTo
fmt.Print(f1(10)) // 20

// 型 Adder をレシーバとして定義されているメソッド AddTo を代入
f2 := Adder.AddTo
fmt.Println(f2(myAdder10, 15)) // 25 ← レシーバとして myAdder10 を指定
```

## 関数とメソッドの使い分け

プログラムのロジックが起動時の設定値や実行中の変更値に依存する場合、その値は構造体に保存されるべきで、ロジックはメソッドとして実装されるべき。

ロジックが入力引数のみに依存するなら関数として実装されるべき。

## 型宣言と継承の違い

新しい型を宣言する際に、基本型[^2024-12-22-204919]や構造体リテラルをベースにできるが、[[ユーザー定義型]][^2024-12-22-205004]をベースにすることもできる。ユーザー定義型を元にした場合、それらの型の間に継承関係や階層関係は存在しない。型変換なしに相互の型の変数の代入はできないし、片方の型に定義されたメソッドはもう片方の方では定義されていない。

[^2024-12-22-204919]: あらかじめ組み込まれている型のこと。

[^2024-12-22-205004]: 自分ですでに定義した型のこと。

[[ユーザー定義型]]に対する演算を行う場合、ベースが基本型ならば、その基本型に対して使える演算子を利用できる。

## iota と列挙型

Goには[[列挙型]] (enum 型) がない代わりに [[iota]][^2024-12-22-225158] があり、徐々に増加する値を一連の定数に割り当てることができる。

[^2024-12-22-225158]: `iota` のコンセプトは APL というプログラミング言語に由来している。

### iota のベストプラクティス

まず取りうる値を表すことになる型を `int` をベースにして定義する。

```go
type MailCategory
```

次に、その型が取りうる値の集合を `const` ブロックで定義する。

```go
const (
	Uncategorized MailCategory = iota // 未分類
	Personal                          // 個人的
	Spam                              // 迷惑メール
	Social                            // ソーシャル
	Advertisements                    // 広告
)
```

`const` ブロックの最初の定数には型 (e.g. `MailCategory`) を指定し、定数の値を `iota`に設定する。その後の行には方も代入値も書かない。Goコンパイラはこれらを処理するときに `iota` の値をインクリメント (0, 1, 2, ...) しながら型指定と代入を繰り返す。

[[iota]] を使う場合は、「実際の値がいくつであっても問題ない場合」、つまり定数が値ではなく名前で参照されるところで使う。値に意味がある場合は `iota` を使うのではなく、定数の値を明示的に指定すること。



source: [[『初めてのGo言語』]]
